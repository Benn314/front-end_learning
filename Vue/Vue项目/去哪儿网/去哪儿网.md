# 第一章 课程介绍

## 1-1

![image-20220831092220390](去哪儿网.assets/image-20220831092220390.png)

![image-20220831092856462](去哪儿网.assets/image-20220831092856462.png)

![image-20220831092901494](去哪儿网.assets/image-20220831092901494.png)

![image-20220831092905687](去哪儿网.assets/image-20220831092905687.png)

![image-20220831092910053](去哪儿网.assets/image-20220831092910053.png)

​	

​	

# 第二章 Vue起步

## 2-1

[Vue2-官方文档](https://v2.cn.vuejs.org/v2/guide/)

> 官方文档是最好的学习工具

​	

## 2-2

**安装-兼容性**

Vue **不支持** IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有[兼容 ECMAScript 5 的浏览器](https://caniuse.com/#feat=es5)。

​	

{{ }} 是差值表达式

![image-20220831103730201](去哪儿网.assets/image-20220831103730201.png)

data 的作用 定义一些数据

el是限制 Vue实例 接管/处理 DOM的范围

​	

Vue.js 让我们不需要关注DOM的操作 而是把精力集中到数据的管理之上了

​	

**2-2.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <div id="app">{{content}}</div>
    <!-- <div>{{content}}</div> -->

    <script>
      //   var dom = document.getElementById("app");
      //   dom.innerHTML = "hello world";

      //   setTimeout(function () {
      //     dom.innerHTML = "bye world";
      //   }, 2000);

      var app = new Vue({
        el: "#app",
        data: {
          content: "hello world1",
        },
      });

      setTimeout(function () {
        app.$data.content = "bye world1";
      }, 2000);
    </script>
  </body>
</html>

```

​	

## 2-3

el 你要使用Vue来接管哪一个标签区域

![image-20220831113604574](去哪儿网.assets/image-20220831113604574.png)

​	

**2-3.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <div id="app">
      <!-- v-model="inputValue"跟input的value属性绑定 -->
      <input type="text" v-model="inputValue" />
      <button v-on:click="handleBtnClick">提交</button>
      <ul>
        <!-- <li>第一课的内容</li> -->
        <li v-for="item in list">{{item}}</li>
      </ul>
    </div>
    <script>
      var app = new Vue({
        el: "#app",
        data: {
          //   list: ["第一课的内容", "第二课的内容", "33333"],
          list: [],
          inputValue: "",
        },
        methods: {
          handleBtnClick: function () {
            // alert("click");
            // alert(this.inputValue);
            this.list.push(this.inputValue);
            this.inputValue = "";
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 2-4 MVVM模式

> Vue是MVVM设计模式

传统MVP设计模式

![image-20220831151245883](去哪儿网.assets/image-20220831151245883.png)

P层是核心层（是V和M的中转站） Model层是边缘层 几乎没有

而MVVM设计模式 几乎把注意力都集中在了M层

所以 我们可以这么理解 以前用jQuery进行开发 我们是面向DOM进行开发；而现在用MVVM进行开发 我们是面向数据进行编程

![image-20220831151255876](去哪儿网.assets/image-20220831151255876.png)

**2-4_MVVM.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TodoList Jquery</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js"></script>
  </head>
  <body>
    <div>
      <input id="input" type="text" />
      <button id="btn">提交</button>
      <ul id="list"></ul>
    </div>

    <script>
      // M 模型层 V 视图 P控制器
      function Page() {}

      $.extend(Page.prototype, {
        init: function () {
          this.bindEvents();
        },
        bindEvents: function () {
          var btn = $("#btn");
          btn.on("click", $.proxy(this.handleBtnClick, this));
        },
        handleBtnClick: function () {
          //   alert("123");
          var inputElem = $("#input");
          var inputValue = inputElem.val();
          var ulElem = $("#list");
          ulElem.append("<li>" + inputValue + "</li>");
          inputElem.val("");
        },
      });

      var page = new Page();
      page.init();
    </script>
  </body>
</html>

```

​	

## 2-5 组件化

![image-20220831161937479](去哪儿网.assets/image-20220831161937479.png)

一个组件就是一个小的区域

​	

## 2-6

`Vue.component()` 是Vue提供给我们创建**全局组件**的方法

**2-6_组件化.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <!-- View 层 -->
    <div id="root">
      <!-- v-model="todoValue"跟input的value属性绑定 -->
      <input type="text" v-model="todoValue" />
      <button v-on:click="handleBtnClick">提交</button>
      <ul>
        <!-- <li>第一课的内容</li> -->
        <!-- <li v-for="item in list">{{item}}</li> -->
        <todo-item v-bind:content="item" v-for="item in list"></todo-item>
      </ul>
    </div>

    <script>
      // 全局组件的使用
      // Vue.component("TodoItem", {
      //   props: ["content"],
      //   // template: "<li>todo item</li>",  //这样写死了 每一项都是同样内容：todo item
      //   // template: "<li>" + this.content + "</li>",  //这么写会有问题 要用差值表达式
      //   template: "<li>{{content}}</li>",
      // });

      //局部组件的使用
      var TodoItem = {
        props: ["content"],
        template: "<li>{{content}}</li>",
      };

      // Model 层
      //components 组件的意思
      var app = new Vue({
        el: "#root",
        components: {
          TodoItem: TodoItem,
        },
        data: {
          //   list: ["第一课的内容", "第二课的内容", "33333"],
          list: [],
          todoValue: "",
        },
        methods: {
          handleBtnClick: function () {
            // alert("click");
            // alert(this.todoValue);
            this.list.push(this.todoValue);
            this.todoValue = "";
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 2-7

通过v-bind进行传值 子(局部)组件记得接收 而后通过$emit向f父组件上一层触发事件 子组件触发事件 父组件进行监听



**2-7.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <!-- View 层 -->
    <div id="root">
      <!-- v-model="todoValue"跟input的value属性绑定 -->
      <input type="text" v-model="todoValue" />
      <button v-on:click="handleBtnClick">提交</button>
      <ul>
        <!-- <li>第一课的内容</li> -->
        <!-- <li v-for="item in list">{{item}}</li> -->
        <todo-item
          v-bind:content="item"
          :index="index"
          v-for="(item,index) in list"
          @delete="handleItemDelete"
        ></todo-item>
      </ul>
    </div>

    <script>
      // 全局组件的使用
      // Vue.component("TodoItem", {
      //   props: ["content"],
      //   // template: "<li>todo item</li>",  //这样写死了 每一项都是同样内容：todo item
      //   // template: "<li>" + this.content + "</li>",  //这么写会有问题 要用差值表达式
      //   template: "<li>{{content}}</li>",
      // });

      //局部组件的使用
      var TodoItem = {
        props: ["content", "index"],
        template: "<li @click='handleItemClick'>{{content}}</li>",
        methods: {
          handleItemClick: function () {
            // alert("click");
            this.$emit("delete", this.index);
          },
        },
      };

      // Model 层
      //components 组件的意思
      var app = new Vue({
        el: "#root",
        components: {
          TodoItem: TodoItem,
        },
        data: {
          //   list: ["第一课的内容", "第二课的内容", "33333"],
          list: [],
          todoValue: "",
        },
        methods: {
          handleBtnClick: function () {
            // alert("click");
            // alert(this.todoValue);
            this.list.push(this.todoValue);
            this.todoValue = "";
          },
          handleItemDelete: function (index) {
            // alert("delete");
            this.list.splice(index, 1);
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 2-8

通读Vue官方文档-介绍 熟悉基础语法

[Vue2-介绍](https://v2.cn.vuejs.org/v2/guide/index.html)

el 是element的缩写 元素

​	

**响应式**

Vue的魔力在于数据的变更，当我们打开控制台改变变量的值 注意在变量分值改变的同时 VUE 自动更新了我们的HTML 这是因为 VUE 是响应式的 也就是说当我们的数据变更时 VUE会帮你更新所有网页中用到它的地方

​	

注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 `#app`) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。

attribute 属性

​	

`v-bind` attribute 被称为**指令** 

指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊 attribute

​	

我们不仅可以把数据绑定到 DOM 文本或 attribute，还可以绑定到 DOM **结构**。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用[过渡效果](https://v2.cn.vuejs.org/v2/guide/transitions.html)。

​	

注意在 `reverseMessage` 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。

Vue 还提供了 `v-model` 指令，它能轻松实现表单输入和应用状态之间的双向绑定。

​	

### [组件化应用构建](https://v2.cn.vuejs.org/v2/guide/index.html#组件化应用构建)

[观看本节视频讲解](https://learning.dcloud.io/#/?vid=12)

组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：

![Component Tree](https://v2.cn.vuejs.org/images/components.png)

​	

property 属性、性质

```js
Vue.component('todo-item', {
  // todo-item 组件现在接受一个
  // "prop"，类似于一个自定义 attribute。
  // 这个 prop 名为 todo。
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})
```

但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 [prop](https://v2.cn.vuejs.org/v2/guide/components.html#通过-Prop-向子组件传递数据)：



​	尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 `<todo-item>` 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。

​	

## 3-1

在官方文档中 我们经常可以看到 vue对象实例 vm、app

handleClick不能定义在其他地方 只能定义在methods下面

​	

我们可以这么理解 一个vue的项目它实际上是由很多组件所组成的，也可以理解成一个vue项目是由很多实例拼装所组成的

因为组件的话 页面是可以分成很多组件的 实际上每个组件就是一个vue实例 一个项目是由vue实例所组成的也没有错误

​	

以 `$` 为开头的都是vue的实例属性/方法

![image-20220831230907977](去哪儿网.assets/image-20220831230907977.png)

​	

![image-20220831232737414](去哪儿网.assets/image-20220831232737414.png)

​	

**3-1.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue实例</title>
    <!-- 两种引入都可以 但是文件必须为超链接形式-->
    <!-- <script src="vue.js"></script> -->
    <script src="./vue.js"></script>
  </head>
  <body>
    <div id="root">
      <div @click="handleClick">{{message}}</div>
      <item></item>
    </div>

    <script>
      Vue.component("item", {
        template: "<div>hello world1</div>",
      });

      var vm = new Vue({
        el: "#root",
        data: {
          message: "hello world",
        },
        methods: {
          handleClick: function () {
            alert("hello");
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 3-2 Vue实例的生命周期钩子

![image-20220901093225747](去哪儿网.assets/image-20220901093225747.png)

![image-20220901093439134](去哪儿网.assets/image-20220901093439134.png)

![image-20220901093446678](去哪儿网.assets/image-20220901093446678.png)

![image-20220901093503457](去哪儿网.assets/image-20220901093503457.png)

![image-20220901103021949](去哪儿网.assets/image-20220901103021949.png)

​	

**3-2-Vue实例的生命周期钩子.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue实例的生命周期函数</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="app">111</div>

    <script>
      // 生命周期函数就是vue实例在某一个时间点会自动执行的函数
      //   Vue的生命周期函数不是放在methods里 而是直接放在Vue的实例里就可以了
      var vm = new Vue({
        el: "#app",
        template: "<div>{{test}}</div>",
        data() {
          // 不加return 会报Warn 无法正常显示
          return {
            test: "hello world",
          };
        },
        //   beforeMount被执行的时候页面还没被渲染
        beforeCreate: function () {
          console.log("beforeCreate");
        },
        //   mounted被执行的时候页面已经渲染了
        created: function () {
          console.log("created");
        },
        beforeMount: function () {
          console.log(this.$el);
          console.log("beforeMount");
        },
        mounted: function () {
          console.log(this.$el);
          console.log("mounted");
        },
        beforeDestroy: function () {
          console.log("beforeDestroy");
        },
        destroyed: function () {
          console.log("destroyed");
        },
        beforeUpdate: function () {
          console.log("beforeUpdate");
        },
        updated: function () {
          console.log("updated");
        },
      });
    </script>
  </body>
</html>

```

​	

**作业**

- 看完  [官方文档-Vue实例](https://v2.cn.vuejs.org/v2/guide/instance.html) 

- [生命周期钩子](https://v2.cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90)

​	

每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的：

虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。

不过现在，你只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。

当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。

除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。

​	

```js
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})
```

​	

每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，==这给了用户在不同阶段添加自己的代码的机会。==

生命周期钩子的 `this` 上下文指向调用它的 Vue 实例。

> 不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，比如 `created: () => console.log(this.a)` 或 `vm.$watch('a', newValue => this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。

![Vue 实例生命周期](https://v2.cn.vuejs.org/images/lifecycle.png)

​	

## 3-3

