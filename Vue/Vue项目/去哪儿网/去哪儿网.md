# 第一章 课程介绍

## 1-1

![image-20220831092220390](去哪儿网.assets/image-20220831092220390.png)

![image-20220831092856462](去哪儿网.assets/image-20220831092856462.png)

![image-20220831092901494](去哪儿网.assets/image-20220831092901494.png)

![image-20220831092905687](去哪儿网.assets/image-20220831092905687.png)

![image-20220831092910053](去哪儿网.assets/image-20220831092910053.png)

​	

​	

# 第二章 Vue起步

## 2-1

[Vue2-官方文档](https://v2.cn.vuejs.org/v2/guide/)

> 官方文档是最好的学习工具

​	

## 2-2

**安装-兼容性**

Vue **不支持** IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有[兼容 ECMAScript 5 的浏览器](https://caniuse.com/#feat=es5)。

​	

{{ }} 是差值表达式

![image-20220831103730201](去哪儿网.assets/image-20220831103730201.png)

data 的作用 定义一些数据

el是限制 Vue实例 接管/处理 DOM的范围

​	

Vue.js 让我们不需要关注DOM的操作 而是把精力集中到数据的管理之上了

​	

**2-2.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <div id="app">{{content}}</div>
    <!-- <div>{{content}}</div> -->

    <script>
      //   var dom = document.getElementById("app");
      //   dom.innerHTML = "hello world";

      //   setTimeout(function () {
      //     dom.innerHTML = "bye world";
      //   }, 2000);

      var app = new Vue({
        el: "#app",
        data: {
          content: "hello world1",
        },
      });

      setTimeout(function () {
        app.$data.content = "bye world1";
      }, 2000);
    </script>
  </body>
</html>

```

​	

## 2-3

el 你要使用Vue来接管哪一个标签区域

![image-20220831113604574](去哪儿网.assets/image-20220831113604574.png)

​	

**2-3.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <div id="app">
      <!-- v-model="inputValue"跟input的value属性绑定 -->
      <input type="text" v-model="inputValue" />
      <button v-on:click="handleBtnClick">提交</button>
      <ul>
        <!-- <li>第一课的内容</li> -->
        <li v-for="item in list">{{item}}</li>
      </ul>
    </div>
    <script>
      var app = new Vue({
        el: "#app",
        data: {
          //   list: ["第一课的内容", "第二课的内容", "33333"],
          list: [],
          inputValue: "",
        },
        methods: {
          handleBtnClick: function () {
            // alert("click");
            // alert(this.inputValue);
            this.list.push(this.inputValue);
            this.inputValue = "";
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 2-4 MVVM模式

> Vue是MVVM设计模式

传统MVP设计模式

![image-20220831151245883](去哪儿网.assets/image-20220831151245883.png)

P层是核心层（是V和M的中转站） Model层是边缘层 几乎没有

而MVVM设计模式 几乎把注意力都集中在了M层

所以 我们可以这么理解 以前用jQuery进行开发 我们是面向DOM进行开发；而现在用MVVM进行开发 我们是面向数据进行编程

![image-20220831151255876](去哪儿网.assets/image-20220831151255876.png)

**2-4_MVVM.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TodoList Jquery</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js"></script>
  </head>
  <body>
    <div>
      <input id="input" type="text" />
      <button id="btn">提交</button>
      <ul id="list"></ul>
    </div>

    <script>
      // M 模型层 V 视图 P控制器
      function Page() {}

      $.extend(Page.prototype, {
        init: function () {
          this.bindEvents();
        },
        bindEvents: function () {
          var btn = $("#btn");
          btn.on("click", $.proxy(this.handleBtnClick, this));
        },
        handleBtnClick: function () {
          //   alert("123");
          var inputElem = $("#input");
          var inputValue = inputElem.val();
          var ulElem = $("#list");
          ulElem.append("<li>" + inputValue + "</li>");
          inputElem.val("");
        },
      });

      var page = new Page();
      page.init();
    </script>
  </body>
</html>

```

​	

## 2-5 组件化

![image-20220831161937479](去哪儿网.assets/image-20220831161937479.png)

一个组件就是一个小的区域

​	

## 2-6

`Vue.component()` 是Vue提供给我们创建**全局组件**的方法

**2-6_组件化.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <!-- View 层 -->
    <div id="root">
      <!-- v-model="todoValue"跟input的value属性绑定 -->
      <input type="text" v-model="todoValue" />
      <button v-on:click="handleBtnClick">提交</button>
      <ul>
        <!-- <li>第一课的内容</li> -->
        <!-- <li v-for="item in list">{{item}}</li> -->
        <todo-item v-bind:content="item" v-for="item in list"></todo-item>
      </ul>
    </div>

    <script>
      // 全局组件的使用
      // Vue.component("TodoItem", {
      //   props: ["content"],
      //   // template: "<li>todo item</li>",  //这样写死了 每一项都是同样内容：todo item
      //   // template: "<li>" + this.content + "</li>",  //这么写会有问题 要用差值表达式
      //   template: "<li>{{content}}</li>",
      // });

      //局部组件的使用
      var TodoItem = {
        props: ["content"],
        template: "<li>{{content}}</li>",
      };

      // Model 层
      //components 组件的意思
      var app = new Vue({
        el: "#root",
        components: {
          TodoItem: TodoItem,
        },
        data: {
          //   list: ["第一课的内容", "第二课的内容", "33333"],
          list: [],
          todoValue: "",
        },
        methods: {
          handleBtnClick: function () {
            // alert("click");
            // alert(this.todoValue);
            this.list.push(this.todoValue);
            this.todoValue = "";
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 2-7

通过v-bind进行传值 子(局部)组件记得接收 而后通过$emit向f父组件上一层触发事件 子组件触发事件 父组件进行监听



**2-7.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./vue.js"></script>
  </head>
  <body>
    <!-- View 层 -->
    <div id="root">
      <!-- v-model="todoValue"跟input的value属性绑定 -->
      <input type="text" v-model="todoValue" />
      <button v-on:click="handleBtnClick">提交</button>
      <ul>
        <!-- <li>第一课的内容</li> -->
        <!-- <li v-for="item in list">{{item}}</li> -->
        <todo-item
          v-bind:content="item"
          :index="index"
          v-for="(item,index) in list"
          @delete="handleItemDelete"
        ></todo-item>
      </ul>
    </div>

    <script>
      // 全局组件的使用
      // Vue.component("TodoItem", {
      //   props: ["content"],
      //   // template: "<li>todo item</li>",  //这样写死了 每一项都是同样内容：todo item
      //   // template: "<li>" + this.content + "</li>",  //这么写会有问题 要用差值表达式
      //   template: "<li>{{content}}</li>",
      // });

      //局部组件的使用
      var TodoItem = {
        props: ["content", "index"],
        template: "<li @click='handleItemClick'>{{content}}</li>",
        methods: {
          handleItemClick: function () {
            // alert("click");
            this.$emit("delete", this.index);
          },
        },
      };

      // Model 层
      //components 组件的意思
      var app = new Vue({
        el: "#root",
        components: {
          TodoItem: TodoItem,
        },
        data: {
          //   list: ["第一课的内容", "第二课的内容", "33333"],
          list: [],
          todoValue: "",
        },
        methods: {
          handleBtnClick: function () {
            // alert("click");
            // alert(this.todoValue);
            this.list.push(this.todoValue);
            this.todoValue = "";
          },
          handleItemDelete: function (index) {
            // alert("delete");
            this.list.splice(index, 1);
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 2-8

通读Vue官方文档-介绍 熟悉基础语法

[Vue2-介绍](https://v2.cn.vuejs.org/v2/guide/index.html)

el 是element的缩写 元素

​	

**响应式**

Vue的魔力在于数据的变更，当我们打开控制台改变变量的值 注意在变量分值改变的同时 VUE 自动更新了我们的HTML 这是因为 VUE 是响应式的 也就是说当我们的数据变更时 VUE会帮你更新所有网页中用到它的地方

​	

注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 `#app`) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。

attribute 属性

​	

`v-bind` attribute 被称为**指令** 

指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊 attribute

​	

我们不仅可以把数据绑定到 DOM 文本或 attribute，还可以绑定到 DOM **结构**。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用[过渡效果](https://v2.cn.vuejs.org/v2/guide/transitions.html)。

​	

注意在 `reverseMessage` 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。

Vue 还提供了 `v-model` 指令，它能轻松实现表单输入和应用状态之间的双向绑定。

​	

### [组件化应用构建](https://v2.cn.vuejs.org/v2/guide/index.html#组件化应用构建)

[观看本节视频讲解](https://learning.dcloud.io/#/?vid=12)

组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：

![Component Tree](https://v2.cn.vuejs.org/images/components.png)

​	

property 属性、性质

```js
Vue.component('todo-item', {
  // todo-item 组件现在接受一个
  // "prop"，类似于一个自定义 attribute。
  // 这个 prop 名为 todo。
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})
```

但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 [prop](https://v2.cn.vuejs.org/v2/guide/components.html#通过-Prop-向子组件传递数据)：



​	尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 `<todo-item>` 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。

​	

​	

# 第三章 Vue 基础精讲

## 3-1

在官方文档中 我们经常可以看到 vue对象实例 vm、app

handleClick不能定义在其他地方 只能定义在methods下面

​	

我们可以这么理解 一个vue的项目它实际上是由很多组件所组成的，也可以理解成一个vue项目是由很多实例拼装所组成的

因为组件的话 页面是可以分成很多组件的 实际上每个组件就是一个vue实例 一个项目是由vue实例所组成的也没有错误

​	

以 `$` 为开头的都是vue的实例属性/方法

![image-20220831230907977](去哪儿网.assets/image-20220831230907977.png)

​	

![image-20220831232737414](去哪儿网.assets/image-20220831232737414.png)

​	

**3-1.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue实例</title>
    <!-- 两种引入都可以 但是文件必须为超链接形式-->
    <!-- <script src="vue.js"></script> -->
    <script src="./vue.js"></script>
  </head>
  <body>
    <div id="root">
      <div @click="handleClick">{{message}}</div>
      <item></item>
    </div>

    <script>
      Vue.component("item", {
        template: "<div>hello world1</div>",
      });

      var vm = new Vue({
        el: "#root",
        data: {
          message: "hello world",
        },
        methods: {
          handleClick: function () {
            alert("hello");
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 3-2 Vue实例的生命周期钩子

![image-20220901093225747](去哪儿网.assets/image-20220901093225747.png)

![image-20220901093439134](去哪儿网.assets/image-20220901093439134.png)

![image-20220901093446678](去哪儿网.assets/image-20220901093446678.png)

![image-20220901093503457](去哪儿网.assets/image-20220901093503457.png)

![image-20220901103021949](去哪儿网.assets/image-20220901103021949.png)

​	

**3-2-Vue实例的生命周期钩子.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue实例的生命周期函数</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="app">111</div>

    <script>
      // 生命周期函数就是vue实例在某一个时间点会自动执行的函数
      //   Vue的生命周期函数不是放在methods里 而是直接放在Vue的实例里就可以了
      var vm = new Vue({
        el: "#app",
        template: "<div>{{test}}</div>",
        data() {
          // 不加return 会报Warn 无法正常显示
          return {
            test: "hello world",
          };
        },
        //   beforeMount被执行的时候页面还没被渲染
        beforeCreate: function () {
          console.log("beforeCreate");
        },
        //   mounted被执行的时候页面已经渲染了
        created: function () {
          console.log("created");
        },
        beforeMount: function () {
          console.log(this.$el);
          console.log("beforeMount");
        },
        mounted: function () {
          console.log(this.$el);
          console.log("mounted");
        },
        beforeDestroy: function () {
          console.log("beforeDestroy");
        },
        destroyed: function () {
          console.log("destroyed");
        },
        beforeUpdate: function () {
          console.log("beforeUpdate");
        },
        updated: function () {
          console.log("updated");
        },
      });
    </script>
  </body>
</html>

```

​	

**作业**

- 看完  [官方文档-Vue实例](https://v2.cn.vuejs.org/v2/guide/instance.html) 

- [生命周期钩子](https://v2.cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90)

​	

每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的：

虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。

不过现在，你只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。

当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。

除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。

​	

```js
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})
```

​	

每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，==这给了用户在不同阶段添加自己的代码的机会。==

生命周期钩子的 `this` 上下文指向调用它的 Vue 实例。

> 不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，比如 `created: () => console.log(this.a)` 或 `vm.$watch('a', newValue => this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。

![Vue 实例生命周期](https://v2.cn.vuejs.org/images/lifecycle.png)

​	

## 3-3 Vue的模板语法

插值表达式是第一种模板语法

当我们看到一个Vue指令后面跟着一个值的时候，大家要知道这里面的值就不再是一个字符串了 它指的一定是一个 js表达式

v-text和插件表达式{{}}的功能实际上是一样的

​	

**3-3_Vue的模板语法.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>模板语法</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="app">
      <!-- {{}} 差值表达式也是js表达式 -->
      <div>{{name + ' Lee'}}</div>
      <div v-text="name+ ' Lee'"></div>
      <div v-html="name+ ' Lee'"></div>
      <!-- v-text原封不动输出js表达式
            而v-html会解析js表达式里的标签效果 -->
    </div>

    <script>
      var vm = new Vue({
        el: "#app",
        data() {
          return {
            name: "<strong> Dell </strong>",
          };
        },
      });
    </script>
  </body>
</html>

```

​	

## 3-4 计算属性、方法和侦听器

![image-20220901193438233](去哪儿网.assets/image-20220901193438233.png)

​	

**3-4_计算属性，方法和侦听器.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>计算属性，方法和侦听器</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <!-- computed -->
    <div id="app">{{fullName}} {{age}}</div>

    <!-- methods 因为是fullName后面需要加()-->
    <!-- <div id="app">{{fullName()}} {{age}}</div> -->

    <script>
      var vm = new Vue({
        el: "#app",
        data: {
          firstName: "Dell",
          lastName: "Lee",
          fullName: "Dell Lee",
          age: 28,
        },
        /*
            watch 监听器
            用watch也能实现相关属性值改变
            fullName才随之改变

            但当watch、methods和computed
            三者都能实现其功能时 优先选computed
            因为语法既简洁、性能又高
        */
        watch: {
          firstName: function () {
            console.log("执行一次");
            this.fullName = this.firstName + " " + this.lastName;
          },
          lastName: function () {
            console.log("执行一次");
            this.fullName = this.firstName + " " + this.lastName;
          },
        },

        // 方法
        // methods: {
        //   /*
        //         fullName写在methods方法里也行
        //         但不如在computed中
        //         因为页面只要重新渲染（例如改变age值）
        //         fullName就会重新被执行一次
        //     */
        //   fullName: function () {
        //     console.log("执行一次");
        //     return this.firstName + " " + this.lastName;
        //   },
        // },

        // 计算属性
        // computed: {
        //   fullName: function () {
        //     console.log("执行一次");
        //     // 计算属性：当computed依赖的属性值发生变化时 function会重新调用一次
        //     return this.firstName + " " + this.lastName;
        //   },
        // },
      });
    </script>
  </body>
</html>

```

​	

## 3-5 计算属性的setter和getter

**3-5_计算属性的setter和getter.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>计算属性的setter和getter</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <!-- 
        找fullName data里找不到呢 去计算属性computed里找
        如果找到了就显示在页面上 
    -->
    <div id="app">{{fullName}}</div>

    <script>
      var vm = new Vue({
        el: "#app",
        data: {
          firstName: "Dell",
          lastName: "Lee",
        },
        computed: {
          //   fullName: function () {
          //     return this.firstName + " " + this.lastName;
          //   },

          //   跟上面的写法效果一样
          fullName: {
            get: function () {
              return this.firstName + " " + this.lastName;
            },
            set: function (value) {
              var arr = value.split(" ");
              this.firstName = arr[0];
              this.lastName = arr[1];
              console.log(value);
            },
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 3-6 Vue中的样式绑定

将js表达式写在标签里，vue属性后的值是js表达式

​	

**3-6_Vue中的样式绑定.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue中的样式绑定</title>
    <script src="vue.js"></script>
    <style>
      .activated {
        color: red;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- <div @click="handleDivClick" :class="{activated: isActivated}"> -->
      <div @click="handleDivClick" :class="[activated,activatedOne]">
        Hello World
      </div>
    </div>

    <div id="app1">
      <!-- <div :style="styleObj" @click="handleDivClick">HELLO WORLD</div> -->
      <!-- :style里是js表达式 要写fontSize  font-size是css的样式 -->
      <div :style="[styleObj,{fontSize:'20px'}]" @click="handleDivClick">
        HELLO WORLD
      </div>
      <!-- 无论通过 :class 或 :style 最后都是通过对象或数组来绑定 -->
    </div>

    <script>
      var vm = new Vue({
        el: "#app",
        data() {
          return {
            isActivated: false,
            activated: "",
            activatedOne: "activated-one",
          };
        },
        methods: {
          handleDivClick: function () {
            // this.isActivated = true;
            // this.isActivated = !this.isActivated;
            // this.activated = "activated";
            // if (this.activated === "activated") {
            //   this.activated = "";
            // } else {
            //   this.activated = "activated";
            // }
            this.activated = this.activated === "activated" ? "" : "activated";
          },
        },
      });

      var vm1 = new Vue({
        el: "#app1",
        data: {
          styleObj: {
            color: "black",
          },
        },
        methods: {
          handleDivClick: function () {
            this.styleObj.color =
              this.styleObj.color === "black" ? "red" : "black";
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 3-7 Vue中的条件渲染

**3-7_Vue中的条件渲染.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue中的条件渲染</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="app">
      <!-- 
            v-if 和 v-else 后面不添加key值的话
            vue会尽量复用页面上的DOM
            所以切换显示div input标签里的value未变
            因为是同一个input

            设置了key值后 标签唯一 如果两个标签key值不一样
            vue便不会去尝试复用以前的这个input
            虚拟DOM的知识
         -->
      <div v-if="show">用户名: <input type="text" key="username" /></div>
      <div v-else="show">邮箱名: <input type="text" key="password" /></div>

      <!-- 也是要连在一起写 不能被其他标签所分隔 -->
      <!-- <div v-if="show==='a'">This is A</div>
      <div v-else-if="show==='b'">This is B</div>
      <div v-else>This is others</div> -->

      <!-- 
            注意 v-if 和 v-else 要紧贴在一起使用
            否则程序无法正确解析 会报错
          -->
      <!-- <div v-if="show">{{message}}</div>
      <div v-else>Bye World</div> -->

      <!-- <div v-if="show" data-test="v-if">{{message}}</div> -->
      <!-- 频繁切换显示隐藏用 v-show 因为它是调用了style的display:none 没有像v-if直接删除 -->
      <!-- <div v-show="show" data-test="v-show">{{message}}</div> -->
    </div>

    <script>
      var vm = new Vue({
        el: "#app",
        data: {
          show: false,
          message: "Hello World",
        },
      });
    </script>
  </body>
</html>

```

​	

![image-20220902001155743](去哪儿网.assets/image-20220902001155743.png)

Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。

在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。

如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，[直接写渲染 (render) 函数](https://v2.cn.vuejs.org/v2/guide/render-function.html)，使用可选的 JSX 语法。

通过使用 [v-once 指令](https://v2.cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：

```html
<span v-once>这个将不会改变: {{ msg }}</span>
```

directive 指令

> 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。

### [Attribute](https://v2.cn.vuejs.org/v2/guide/syntax.html#Attribute)

Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 [`v-bind` 指令](https://v2.cn.vuejs.org/v2/api/#v-bind)：

```html
<div v-bind:id="dynamicId"></div>
```

对于布尔 attribute (它们只要存在就意味着值为 `true`)，`v-bind` 工作起来略有不同，在这个例子中：

```html
<button v-bind:disabled="isButtonDisabled">Button</button>
```

如果 `isButtonDisabled` 的值是 `null`、`undefined` 或 `false`，则 `disabled` attribute 甚至不会被包含在渲染出来的 `<button>` 元素中。

这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。

```html
<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}

<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

### [指令](https://v2.cn.vuejs.org/v2/guide/syntax.html#指令)

[观看本节视频讲解](https://learning.dcloud.io/#/?vid=6)

指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。指令 attribute 的值预期是**单个 JavaScript 表达式** (`v-for` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：

```html
<p v-if="seen">现在你看到我了</p>
```

这里，`v-if` 指令将根据表达式 `seen` 的值的真假来插入/移除 `<p>` 元素。

​	

## 3-8 Vue中的列表渲染

![image-20220902113126398](去哪儿网.assets/image-20220902113126398.png)

![image-20220902113135145](去哪儿网.assets/image-20220902113135145.png)

![image-20220902113149385](去哪儿网.assets/image-20220902113149385.png)

![image-20220902113315097](去哪儿网.assets/image-20220902113315097.png)

![image-20220902113403514](去哪儿网.assets/image-20220902113403514.png)

![image-20220902113412099](去哪儿网.assets/image-20220902113412099.png)

![image-20220902115506513](去哪儿网.assets/image-20220902115506513.png)

![image-20220902115523263](去哪儿网.assets/image-20220902115523263.png)

​	

**3-8_Vue中的列表渲染.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue中的列表渲染</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="app">
      <!-- key指 键名 -->
      <div v-for="(item,key,index) of userInfo">
        {{item}} --- {{key}} --- {{index}}
      </div>

      <!-- 能用in 但推荐of google一下原因 -->
      <!-- :key="index" 频繁使用index 性能不高 -->
      <!-- 遍历两个标签 方法一 在外围新建一个div 包裹要循环内容 -->

      <!-- <div v-for="(item,index) of list" :key="item.id">
        {{item.text}} ---- {{index}}
      </div>
      <span v-for="(item,index) of list" :key="item.id"> {{item.text}} </span> -->

      <!-- <div v-for="(item,index) of list" :key="item.id">
        <div>{{item.text}} ---- {{index}}</div>
        <span> {{item.text}} </span>
      </div> -->

      <!-- 遍历两个标签 方法二 使用template 模板占位符

        将div 改为 template 模板占位符 渲染页面时便没有最外层标签了
        template 不会被渲染到页面上
       -->
      <!-- <template v-for="(item,index) of list" :key="item.id">
        <div>{{item.text}} ---- {{index}}</div>
        <span> {{item.text}} </span>
      </template> -->
    </div>

    <script>
      // 一共有这7个操作数组的方法
      // push pop shift unshift splice sort reverse
      var vm = new Vue({
        el: "#app",
        data: {
          //   list: ["hello", "dell", "nice", "to", "meet", "you"],
          list: [
            // {
            //   id: "010120201",
            //   text: "hello",
            // },
            // {
            //   id: "010120202",
            //   text: "Dell",
            // },
            // {
            //   id: "010120203",
            //   text: "Lee",
            // },
          ],
          userInfo: {
            name: "Dell",
            age: 28,
            gender: "male",
            salary: "secret",
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 3-9 Vue中的set方法

![image-20220902125550854](去哪儿网.assets/image-20220902125550854.png)

![image-20220902125603815](去哪儿网.assets/image-20220902125603815.png)

![image-20220902130006236](去哪儿网.assets/image-20220902130006236.png)

![image-20220902130039698](去哪儿网.assets/image-20220902130039698.png)

![image-20220902130053017](去哪儿网.assets/image-20220902130053017.png)

​	

**3-9_Vue中的set方法.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue中的set方法</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="app">
      <div v-for="item of userinfo">
        <!-- <div v-for="(item,key,index) of userinfo"> -->
        <!-- {{item}} --- {{key}} --- {{index}} -->
        {{item}}
      </div>
    </div>

    <script>
      var vm = new Vue({
        el: "#app",
        data: {
          userinfo: [1, 2, 3, 4],
          //   {
          //     name: "Dell",
          //     age: 28,
          //     gender: "male",
          //     salary: "secret",
          //   },
        },
      });
    </script>
  </body>
</html>

```

​	

​	

# 第四章 深入理解 Vue组件

## 4-1 组件使用的细节点

细节有三

1. 知识点一：使用is属性解决标签渲染中会出现的小bug
2.  知识点二：component中的data属性必须是带有返回值的函数
3. 知识点三：引用ref操作dom元素以及ref在标签和组件中引用的区别

**4-1_组件使用的细节点.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4-1 组件使用的细节点</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <!-- 解决标签渲染中会出现的小bug -->

    <div id="root">
      <!-- <table>
        <tbody> -->
      <!-- <tr>
            <td>1</td>
          </tr>
          <tr>
            <td>2</td>
          </tr>
          <tr>
            <td>3</td>
          </tr> -->

      <!-- 
            这便是一个正常的子组件的使用 
            但这样tbody里没有tr会有bug，不知原因请自行google
            tbody没检索到tr标签 会将其里面的标签移到外面
            通过is属性来解决此bug
          -->
      <!-- <row></row>
          <row></row>
          <row></row> -->

      <!-- 规定 tbody里面要有tr 否则会有bug  模板会在tbody外面 -->
      <!-- <tr is="row"></tr>
          <tr is="row"></tr>
          <tr is="row"></tr> -->
      <!-- 
            知识点一：使用is属性解决标签渲染中会出现的小bug
            可以用 is属性来解决 用is表示 这里虽然是一个tr
            但它实际上是 row这么一个组件 这么写既能保证
            tr里面即是我们的组件 又能让它符合H5的这么一个规范
            这样就不会有bug啦
           -->

      <!-- 
            而使用ul组件时，建议也不要直接row
            有时在浏览器上也可能会有问题
            ul支持的是li标签 在li中通过用is='row'来代替row组件
            ol(里是 li)和select(里是 option)标签中也一样

            使用is属性解决模板标签上出现bug的问题
            -->
      <!-- <ul>
            <ol></ol>
          </ul> -->
      <!-- <ul is="row1"></ul> -->

      <!-- <select name="" id="">
            <option value="" ></option>
          </select> -->
      <!-- <select name="" id="" is="row2"></select> -->
      <!-- </tbody>
      </table> -->

      <!-- 有一些复杂情况需要在Vue里操作DOM 可以用ref引入的形式来操作DOM -->
      <!-- <div ref="hello" @click="handleClick">hello world</div> -->
      <!-- 前面获取的是标签的dom元素 如果换成组件呢？(例如item) -->
      <!-- <item ref="hello" @click="handleClick">hello world</item> -->

      <!-- 知识点三：引用ref操作dom元素以及ref在标签和组件中引用的区别 -->
      <!-- ref在标签上引用时 获取是标签的dom元素 
            而在组件上引用时 获取的是该子组件的引用 -->
      <counter ref="one" @change="handleChange"></counter>
      <counter ref="two" @change="handleChange"></counter>
      <div>{{total}}</div>
    </div>

    <script>
      Vue.component("row", {
        /* 
            知识点二：component中的data属性必须是带有返回值的函数
            在Vue实例中 将data定义成一个对象没有问题
            但在全局Vue component中 data必须是函数
            且带有return 返回值

            这样设计是好处是子组件之间没有共享一套数据
            可以传入不同的数据 且不相互影响
        */
        data: function () {
          return {
            content: "this is a row",
            number: 0,
          };
        },
        // template: "<tr><td>this is a row</td></tr>",
        // template: "<tr><td>{{content}}</td></tr>",
      });

      //   Vue.component("row1", {
      //     template: "<ul><ol>this is a row</ol></ul>",
      //   });
      //   Vue.component("row2", {
      //     template: "<select><option>this is a row</option></select>",
      //   });

      Vue.component("counter", {
        template: '<div @click="handleClick">{{number}}</div>',
        data: function () {
          return {
            number: 0,
          };
        },
        methods: {
          handleClick: function () {
            this.number++;
            this.$emit("change");
          },
        },
      });

      var vm = new Vue({
        el: "#root",
        data: {
          total: 0,
        },
        methods: {
          handleClick: function () {
            // alert("click");
            console.log(this.$refs.hello); //获取该组件的dom节点
            console.log(this.$refs.hello.innerHTML); //获取该组件的dom节点的内容
          },
          handleChange: function () {
            // alert("change");
            // console.log(this.$refs.one.number);
            // console.log(this.$refs.two.number);
            this.total = this.$refs.one.number + this.$refs.two.number;
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 4-2 父子组件的数据传递

vue中有一个`单向数据流`的概念 父组件可以任意向子组件传递参数，而子组件不能随意修改父组件传递过来的参数，否则会有Vue Warn

而为什么会有这个概念呢 因为传递的数据例如是引用型的，例如对象

子组件修改了父组件传递过来的数据，因为是引用，可能不单单是一处，数据其他不需要修改的地方也会发生变更 这是很危险的

​	

**4-2_父子组件的数据传递.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4-2 父子组件的数据传递</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="root">
      <!-- 父组件通过属性的形式向子组件传递数据 

            这里count的0和1 是字符串
            :count的0和1 是数字

            因为加了: count属性值便是一个js表达式了 不是字符串
        -->
      <!-- count值改成1和2 页面就会显示1和2 -->
      <counter :count="1" @inc="handleIncrease"></counter>
      <counter :count="2" @inc="handleIncrease"></counter>
      <div>{{total}}</div>
    </div>
    <script>
      var counter = {
        /* 
          vue中有一个`单向数据流`的概念 父组件可以任意向子组件传递参数，
          而子组件不能随意修改父组件传递过来的参数，否则会有Vue Warn
          而为什么会有这个概念呢 因为传递的数据例如是引用型的，例如对象
          子组件修改了父组件传递过来的数据，因为是引用，可能不单单是一处，
          数据其他不需要修改的地方也会发生变更 这是很危险的

          如何解决？可以在counter对象中定义一个data属性
          复制一份父组件传递过来的数据 原始数据保持不动
          在子组件使用复制的数据变量即可
        */
        props: ["count"], //props用来接收父组件传递给子组件的数据
        data: function () {
          return {
            number: this.count,
          };
        },
        template: "<div @click='handleClick'>{{number}}</div>",
        methods: {
          handleClick: function () {
            // this.number++;
            this.number = this.number + 2;

            // $emit 向外触发change事件
            // this.$emit("change", 2);
            this.$emit("inc", 2);
          },
        },
      };

      var vm = new Vue({
        el: "#root",
        data: {
          total: 5,
        },
        components: {
          counter: counter, //这里不太理解
        },
        methods: {
          handleIncrease: function (step) {
            // alert("inc");
            // alert(step);
            this.total += step;
            /* 
              父组件通过属性的形式向子组件进行传值
              子组件通过事件触发的方式向父组件进行传值

              这里的emit传递的参数可以被handleIncrease的参数接收
            */
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 4-3 组件参数校验与非props特性

props特性 

1. 父组件传 子组件接 子组件可以直接用父组件传过来的数据
2. 不会把属性显示在你的dom标签中

---

非props特性

1. 父组件传 子组件不接 那么在子组件中就没法使用父组件传递过来的数据
2. 非props特性的属性值会显示在子组件最外层的html的属性中
3. 非props特性使用场景不多

​	

**4-3_组件参数校验与非props特性.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4-3 组件参数校验与非props特性</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="root">
      <!-- <child :content="123"></child> -->
      <!-- <child></child> -->

      <!-- content只有4位 校验失败 报Vue Warn -->
      <child content="hell"></child>
    </div>

    <script>
      Vue.component("child", {
        // props: ["content"], //没有约束的写法
        // 父组件传递 子组件声明进行接收 这是props特性
        // props: {
        //   //   content: String, //有约束可以写成对象进行约束
        //   //   content: Number, //要求传递过来是数字就这么写
        //   //   content: [Number, String], //这么写的意思是子组件接收的数据类型要么是数字要么是字符串

        //   //也可以通过对象的形式来约束
        //   content: {
        //     type: String,
        //     // required: false, //required 表示是否一定要接收属性值
        //     // default: "default value", //当标签的innerHTML没有内容时 默认使用default的值
        //     // // validator 校验器
        //     // validator: function (value) {
        //     //   return value.length > 5;
        //     // },
        //   },
        // },
        // template: "<div>{{content}}</div>",
        template: "<div>hello</div>",

        /* 
            非props的特性
            1. 父组件传递 子组件用插值表达式接收不到 因为未声明
            2.父组件设置的属性(例如这里的 content) 在页面dom渲染时会渲染到页面上
        */
      });

      var vm = new Vue({
        el: "#root",
      });
    </script>
  </body>
</html>

```

​	

## 4-4 给组件绑定原生事件

监听原生事件只需要在监听的属性后面添加native修饰符就可以啦

​	

**4-4_给组件绑定原生事件.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4-4 给组件绑定原生事件</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="root">
      <!-- 
        没加native是监听自定义事件 加了是监听原生事件 父组件的 

        直接在@click后面加 .native 表示我监听的不是自定义事件
        （监听自定义事件需要通过子组件的两层传递）而直接监听原生事件则不用
      -->
      <child @click.native="handleClick"></child>
    </div>

    <script>
      Vue.component("child", {
        template: "<div>Child</div>",
        // template: "<div @click='handleChildClick'>Child</div>",
        // methods: {
        //   handleChildClick: function () {
        //     // alert("child click");
        //     this.$emit("click");
        //     /*
        //     父组件无法直接自定义事件的触发 子组件可以
        //     父组件需要通过$emit监听事件来触发事件

        //     就想监听原生的事件 需要通过子组件两层的传递太麻烦 我们可以这么做
        //     */
        //   },
        // },
      });

      var vm = new Vue({
        el: "#root",
        methods: {
          handleClick: function () {
            alert("click");
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 4-5 非父子组件间的传值

非父子组件的传值问题，有两种解决方法

1. 使用vue官方提供的vuex框架（有难度）

2. 使用总线机制（通过bus总线来解决非父子组件间复杂的传值问题）

![image-20220903171539120](去哪儿网.assets/image-20220903171539120.png)

​	

**4-5_非父子组件间的传值.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4-5 非父子组件间的传值(Bus/总线/发布订阅模式/观察者模式)</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="root">
      <child content="Dell"></child>
      <child content="Lee"></child>
      <child content="Lee1"></child>
    </div>

    <script>
      // bus写在Vue的原型上 每一个Vue实例都会有一个bus
      Vue.prototype.bus = new Vue();

      Vue.component("child", {
        /* 
            因为Vue的单向数据流原因
            我们需要对父组件传递过来的数据进行拷贝
            才能修改其值 否则会Vue Warn
        */
        data: function () {
          return {
            selfContent: this.content,
          };
        },
        props: {
          content: String,
        },
        template: "<div @click='handleClick'>{{selfContent}}</div>",
        methods: {
          handleClick: function () {
            // alert(this.content);
            this.bus.$emit("change", this.selfContent);
          },
        },
        // 生命周期钩子
        mounted: function () {
          var this_ = this;
          // 监听到change 触发事件
          // 这里一次点击会触发两次的原因是有两个模板标签的原型拥有bus属性 所以会导致两次触发事件
          // 如果是三个拥有bus属性的标签就触发三次
          this.bus.$on("change", function (msg) {
            // alert(msg);
            // this.content = msg;  //content无法被修改
            // 原因：这里的content值没有发生变化是因为this作用域因为事件触发发生了改变
            this_.selfContent = msg;

            // 不解的是this作用域怎么发生改变，发生了怎么的改变
            // 这里我们来尝试调试进行查看
            /* 
                目前的理解：
                这里比如我点击了content="Dell"的组件 mounted里的this作用域就
                变成全部指向Dell的作用域吗，所以其他组件content值没法得到修改？

                这个本质属于组件传值的问题，还是不要在这个阶段去纠结这个东西
                现在解决没有很多营养，脑子听过这个名词+基本的代码量就好了
                我个人很讨厌这种bus通信
                代码可维护性太差了
                一般组件通信如果写成这种了，多半是组件设计就有问题

                所以孙传爷实际开发是不允许的吗 传递也只能通过emit一层层传递？(效率低？)
                    允许 前提是你设计的没问题
            */
            console.log(this_);
            console.log(this);
          });
        },
      });

      var vm = new Vue({
        el: "#root",
      });
    </script>
  </body>
</html>

```

​	

## 4-6 在Vue中使用插槽

插槽很重要

![image-20220904113520813](去哪儿网.assets/image-20220904113520813.png)

![image-20220904114346994](去哪儿网.assets/image-20220904114346994.png)

![image-20220904115018592](去哪儿网.assets/image-20220904115018592.png)

​	

**4-6_在Vue中使用插槽.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4-6 Vue中的插槽(slot)</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="root">
      <!-- <child content="<p>Dell</p>"></child> -->
      <!-- 
        而像我们传递的标签很多时，代码会变得难以阅读 而且下面圈出的div标签不是我们想要的
        这时我们便可以通过插槽来解决
       -->
      <!-- <child
        content="<p>Dell</p><p>Dell</p><p>Dell</p><p>Dell</p><p>Dell</p>
        <p>Dell</p><p>Dell</p>"
      ></child> -->

      <body-content>
        <!-- <h1>Dell</h1> -->
        <!-- 
            这里都是slot插槽的内容
            这里一个<slot></slot>便会显示一遍header footer

            给他们分别设置唯一标识便可以单独使用了

            这里如果没有name为header的插槽 就会使用默认插槽 可以使其显示默认值
         -->
        <!-- <div class="header" slot="header">header</div> -->
        <div class="footer" slot="footer">footer</div>
      </body-content>
    </div>

    <script>
      Vue.component("body-content", {
        props: ["content"],
        // 这么写有一个问题就是多出了一个div标签 而换成template也不行 该行标签直接消失了
        // template: '<div><p>hello</p><div v-html="this.content"></div></div>',

        /* 
            使用slot插槽标签便可以使用父组件传递过来的数据了

            所以通过插槽 我们可以更方便地向子组件传递dom元素
            使用插槽也非常简单 使用slot标签即可
            而slot也有一些新特性 我们可以在slot写默认的值

            如果child模板标签里没有内容 slot标签就会显示默认内容
        */
        // template: "<div><p>hello</p><slot>默认内容</slot></div>",
        template:
          // 所以这里的header footer会显示两遍
          //   "<div><slot></slot><div class='content'>content</div><slot></slot></div>",
          // 用name属性接收一下slot标识
          "<div><slot name='header'><h1>default header</h1></slot><div class='content'>content</div><slot name='footer'></slot></div>",
      });

      var vm = new Vue({
        el: "#root",
      });
    </script>
  </body>
</html>

```

​	

## vue官方文档 模板语法-列表渲染

> vue.js计算属性默认只有 getter，因为是默认值所以我们也常常省略不写，如下代码

**计算属性function().html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="demo">{{ fullName }}</div>

    <script>
      /* 
            在 Vue 中，computed 的属性可以被视为是 data 一样，可以读取和设值，
            因此在 computed 中可以分成 getter（读取） 和 setter（设值），
            一般情况下是没有 setter 的，computed 预设只有 getter ，也就是只能读取，不能改变设值。
            vue.js计算属性默认只有 getter，因为是默认值所以我们也常常省略不写，如下代码：
        */
      var vm = new Vue({
        el: "#demo",
        data: {
          firstName: "Foo",
          lastName: "Bar",
        },
        // computed: {
        //   fullName: function () {
        //     return this.firstName + " " + this.lastName;
        //   },
        // },

        // 这样写也是可以的 省略function和get(){} 没有报错
        computed: {
          fullName() {
            return this.firstName + " " + this.lastName;
          },
        },

        // computed: {
        //   fullName: {
        //     get() {
        //       return this.firstName + " " + this.lastName;
        //     },
        //   },
        // },
      });
    </script>
  </body>
</html>

```

​	

side effect 副作用

```html
<p>Reversed message: "{{ reversedMessage() }}"</p>
```

```js
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是**计算属性是基于它们的响应式依赖进行缓存的**。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。

这也同样意味着下面的计算属性将不再更新，因为 `Date.now()` 不是响应式依赖：

```js
computed: {
  now: function () {
    return Date.now()
  }
}
```

这里的now函数没有属性值会发生改变，因为连属性值都没有

相比之下，每当触发重新渲染时，调用方法将**总会**再次执行函数。

我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 **A**，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 **A**。如果没有缓存，我们将不可避免的多次执行 **A** 的 getter！如果你不希望有缓存，请用方法来替代。

> 为什么需要缓存？ 减少性能消耗

split  拆分 分隔

​	

## 4-7 Vue中的作用域插槽

**4-7_Vue中的作用域插槽.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4-7 Vue中的作用域插槽</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="root">
      <child>
        <!-- 作用域插槽 template和slot固定搭配 -->
        <template slot-scope="props">
          <!-- props 可以使h1这个作用域插槽接收来自template的属性值 -->
          <!-- <li>{{props.item}}</li> -->
          <h1>{{props.item}}</h1>
        </template>
      </child>
    </div>

    <script>
      Vue.component("child", {
        data() {
          return {
            list: [1, 2, 3, 4],
          };
        },
        // 内部只负责循环 传递什么参数/值由外部决定
        template: `<div>
                      <ul>
                        <slot 
                            v-for="item of list"
                            :item=item
                          ></slot>
                      </ul>
                   </div>`,
      });

      var vm = new Vue({
        el: "#root",
      });
    </script>
  </body>
</html>

```

​	

## 4-8 动态组件与v-once指令

动态组件的意思就是它会根据is里面数据的变化自动加载不同的组件

​	

**4-8_动态组件与v-once指令.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>动态组件与v-once指令</title>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="root">
      <!-- 除了刚才那种方式（传统方式） 我们还可以用动态组件来实现 -->
      <!-- <component :is="type"></component> -->

      <!-- 
        传统方式 以视频为例 点击一次button 底层需要销毁当前的组件 然后创建新的组件并显示
        当我们来回点击时 这是需要消耗一定的性能的 如果我们每一次切换显示的内容都一样
        便可以为我们来回切换的组件加一个v-once指令
       -->
      <child-one v-if="type === 'child-one'"></child-one>
      <child-two v-if="type === 'child-two'"></child-two>
      <button @click="handleBtnClick">change</button>
    </div>

    <script>
      Vue.component("child-one", {
        /* 
            有了v-once指令 点击change直接就放到内存里了
            而切换回来时 并不需要重新创建一个child-one组件
            直接从内存提取出来 它的性能会更高一些

            其实就是空间换时间

            所以我们知道 在vue中 通过v-once指令可以有效提高一些
            静态内容的展示效率
        */
        template: "<div v-once>child-one</div>",
      });
      Vue.component("child-two", {
        template: "<div v-once>child-two</div>",
      });

      var vm = new Vue({
        el: "#root",
        data: {
          type: "child-one",
        },
        methods: {
          handleBtnClick: function () {
            this.type = this.type === "child-one" ? "child-two" : "child-one";
          },
        },
      });
    </script>
  </body>
</html>

```

​	

​	

# 第五章 Vue中的动画特效

## 5-1 Vue中CSS动画原理

opacity 不透明度

transition 过渡

所以 transition 标签所包裹的动画效果也叫过渡动画效果(CSS动画)

​	

![image-20220906103112457](去哪儿网.assets/image-20220906103112457.png)

​	

隐藏的动画效果流程

![image-20220906100752680](去哪儿网.assets/image-20220906100752680.png)

![image-20220906103350663](去哪儿网.assets/image-20220906103350663.png)

​	

**5-1_Vue中CSS动画原理.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5-1 Vue中CSS动画原理</title>
    <script src="vue.js"></script>
    <style>
      /* .fade-enter {
        opacity: 0;
      }
      .fade-enter-active {
        transition: opacity 1s;
      } */
      /* 
      这样写动画也是可以的 默认前缀是v-  变成fade- 
      只是我们给它起了个 name="fade" 
      */
      /* 显示动画 */
      /* .v-enter {
        opacity: 0;
      }
      .v-enter-active {
        transition: opacity 1s;
      } */
      /* 隐藏动画 */
      /* 
        opacity（v-leave 开始）本来是1，通过v-leave-to（结果）设置为0
        v-leave-active在过渡过程一直存在并监听 监听到opacity从1变为0
        那么会有3s的过渡效果 
      */
      /* .v-leave-to {
        opacity: 0;
      }
      .v-leave-active {
        transition: opacity 1s;
      } */
      /* 可以对样式进行简写 */
      .v-enter,
      .v-leave-to {
        opacity: 0;
      }
      .v-enter-active,
      .v-leave-active {
        transition: opacity 1s;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <!-- transition 它包裹的动画会有一个过渡效果 -->
      <!-- <transition name="fade"> -->
      <!-- 
            然后这种是对transition包裹的所有标签都生效
            如果只想对其中的某一个标签进行动画效果的话 
            可以加一个name属性进行唯一身份标识 
            再把"前缀v-" 换成"name值-" 就ok了
         -->
      <transition>
        <!-- 这里用 v-show 还是 v-if 都可以 甚至可以在这里写动态组件
             动态组件也会有动画效果 -->
        <div v-if="show">hello world</div>
      </transition>
      <button @click="handleClick">切换</button>
    </div>

    <script>
      var vm = new Vue({
        el: "#root",
        data: {
          show: true,
        },
        methods: {
          handleClick() {
            this.show = !this.show;
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 5-2 在Vue中使用Animate.css库

animate 动画

transform 使变形

scale **缩放**

bounce 弹跳

![bounce-Animate.css](去哪儿网.assets/bounce-Animate.css.gif)

​	

> Animate.css v4 带来了一些**重大变化**，请在从 v3.x 及以下更新之前参考[迁移指南。](https://animate.style/#migration)

**Animate.css**是一个现成的跨浏览器动画库，可用于您的 Web 项目。非常适合强调、主页、滑块和注意力引导提示。

使用 CDN 将其直接添加到您的网页：

```html
<head>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  />
</head>
```

### 基本用法

安装 Animate.css 后，将类`animate__animated`与任何[动画名称](https://animate.style/#attention_seekers)一起添加到元素（不要忘记`animate__`前缀！）：

```html
<h1 class="animate__animated animate__bounce">An animated element</h1>
```

而已！你有一个 CSS 动画元素。极好的！

​	

**5-2_在Vue中使用Animate.css库.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5-2_在Vue中使用Animate.css库</title>
    <script src="vue.js"></script>
    <link rel="stylesheet" type="text/css" href="animate.css" />

    <!-- 使用 CDN 将其直接添加到您的网页： -->
    <!-- <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    /> -->

    <style>
      @keyframes bounce-in {
        0% {
          transform: scale(0);
        }
        50% {
          transform: scale(1.5);
        }
        100% {
          transform: scale(1);
        }
      }
      .fade1-enter-active {
        transform-origin: left center;
        animation: bounce-in 1.5s;
      }
      .fade1-leave-active {
        /* reverse 反转 反向执行
      不加这个 动画运行可能有点问题 显示不出来  */
        transform-origin: left center;
        animation: bounce-in 1.5s reverse;
      }
      /* .active {
        transform-origin: left center;
        animation: bounce-in 1.5s;
      }
      .leave {
        /* reverse 反转 反向执行 */
      /* 不加这个 动画运行可能有点问题 显示不出来 
        transform-origin: left center;
        animation: bounce-in 1.5s reverse;
      } */
    </style>
  </head>
  <body>
    <!-- 安装 Animate.css 后，将类animate__animated与任何动画名称一起添加到元素（不要忘记animate__前缀！）： -->
    <h1 class="animate__animated animate__bounce">An animated element</h1>
    <div id="root">
      <!-- 可以这么命名 引入animate.css 在transition添加enter-active-class -->
      <!-- 
        enter-active-class="active"
        leave-active-class="leave"
        跟上面style样式进行关联
       -->
      <!-- <transition
        name="fade"
        enter-active-class="active"
        leave-active-class="leave"
      > -->
      <!-- 
            使用animate.css这个库 首先要使用自定义的属性enter/leave-active-class
            第二 class类必须包含animated这个类 后面跟动画效果名
         -->
      <transition
        name="fade"
        enter-active-class="animate__animated animate__flip"
        leave-active-class="animate__animated animate__flipInY"
      >
        <div v-if="show">hello world</div>
      </transition>

      <transition name="fade1">
        <div v-if="show1">hello world</div>
      </transition>

      <button @click="handleClick">flip</button>
      <button @click="handleClick1">bounce</button>
    </div>

    <script>
      var vm = new Vue({
        el: "#root",
        data: {
          show: true,
          show1: true,
        },
        methods: {
          handleClick() {
            this.show = !this.show;
          },
          handleClick1() {
            this.show1 = !this.show1;
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 5-3 在Vue中同时使用过渡和动画

duration 时长 持续时间

​	

**5-3_在Vue中同时使用过渡和动画.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5-3 在Vue中同时使用过渡和动画</title>
    <script src="vue.js"></script>
    <link rel="stylesheet" type="text/css" href="animate.css" />

    <!-- animate.css库跟我们自己用@keyframes没区别它只是封装起来而已 -->

    <style>
      .fade-enter,
      .fade-leave-to {
        opacity: 0;
      }
      .fade-enter-active,
      .fade-leave-active {
        transition: opacity 1s;
      }
    </style>
  </head>
  <body>
    <!-- 安装 Animate.css 后，将类animate__animated与任何动画名称一起添加到元素（不要忘记animate__前缀！）： -->
    <h1 class="animate__animated animate__bounce">An animated element</h1>
    <div id="root">
      <!-- 因为过渡动画和animate.css动画的时长不同，有时候vue自己也搞不明白
            我们可以设置一个type来规定以哪一个动画时长为准 

            当然我们也可以自定义动画时长 用自定义属性duration 单位是ms 毫秒
            修改一下时长 可以到控制台检验样式 ctrl shift C选中元素查看网页源代码

            也可以自定义入场动画和出场动画持续的时间 enter是入场动画 leave是出场动画
            :duration="5000"    //默认是出场动画
            :duration="{enter:5000,leave:10000}"
        -->
      <transition
        :duration="{enter:5000,leave:10000}"
        type="transition"
        name="fade"
        appear
        enter-active-class="animate__animated animate__flip fade-enter-active"
        leave-active-class="animate__animated animate__flipInY fade-leave-active"
        appear-active-class="animate__animated animate__flip"
      >
        <div v-if="show">hello world</div>
      </transition>

      <button @click="handleClick">flip</button>
    </div>

    <script>
      var vm = new Vue({
        el: "#root",
        data: {
          show: true,
        },
        methods: {
          handleClick() {
            this.show = !this.show;
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 5-4 Vue中的JS动画与Velocity.js的结合

Velocity 是一个js的动画库 蛮有趣的 借鉴了animate.css动画

**5-4_Vue中的JS动画与Velocity.js的结合.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5-4 Vue中的JS动画与Velocity.js的结合</title>
    <script src="vue.js"></script>

    <!-- 在线CDN -->
    <!-- <script src="//cdn.jsdelivr.net/npm/velocity-animate@2.0/velocity.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/2.0.6/velocity.min.js"></script> -->

    <script src="velocity.js"></script>
  </head>
  <body>
    <div id="root">
      <transition
        name="fade"
        @before-enter="handleBeforeEnter"
        @enter="handleEnter"
        @after-enter="handleAfterEnter"
      >
        <!--  
        @before-leave @leave @after-leave : leave用法和enter一样 这里不赘述了
       -->
        <div v-show="show">hello world</div>
      </transition>
      <button @click="handleClick">toggle</button>
    </div>

    <script>
      var vm = new Vue({
        el: "#root",
        data: {
          show: true,
        },
        methods: {
          handleClick() {
            this.show = !this.show;
          },
          /* 
          handleBeforeEnter有接收到一个el的参数
            是来自transition包裹的div标签
          */
          handleBeforeEnter(el) {
            // console.log("el = " + el);
            // handleBeforeEnter是在enter显示之前执行的 见名知义
            // el.style.color = "pink";
            // 下面用velocity.js来实现动画
            el.style.opacity = 0;
          },
          handleEnter(el, done) {
            // done是回调函数
            // setTimeout(() => {
            //   // el.style.color = "green";
            //   //   当函数执行完的时候 我们应该手动执行done这个函数 告诉vue我们的函数已经执行完了
            //   // done();
            //   // 然后到了下一阶段 after-enter
            //
            // }, 2000);
            //setTimeout是异步操作 所以两个定时器同时执行 最终不会显示绿色 而会直接显示黑色
            // 因为黑色是最后的定时器
            // setTimeout(() => {
            //   // 为了让动画清晰明了点，设置2s后才执行done()
            //   done();
            // }, 3000);

            // 下面用velocity.js来实现动画
            Velocity(el, { opacity: 1 }, { duration: 1000, complete: done });
            // 当函数执行完时 complete里的内容就会被自动执行
          },
          handleAfterEnter(el) {
            // el.style.color = "#000";
            // 下面用velocity.js来实现动画
            console.log("动画结束");
          },
          // 以上操作的变色都是通过js的钩子来进行
        },
      });
    </script>
  </body>
</html>

```

​	

## 5-5 Vue中多个元素或组件的过渡

多个组件的过渡动画有两种的方法 一种的把个个组件写清楚 采用if-else的结构 第二种的使用动态组件component 在methods中可以使用三元运算符来进行动态组件的切换

​	

**5-5_Vue中多个元素或组件的过渡.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5-5 Vue中多个元素或组件的过渡</title>
    <script src="vue.js"></script>
    <!-- <script src="velocity.js"></script> -->
    <style>
      .v-enter,
      .v-leave-to {
        opacity: 0;
      }
      .v-enter-active,
      .v-leave-active {
        transition: opacity 1s;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <!-- <transition mode="in-out"> -->
      <transition mode="out-in">
        <!-- 
            transition中有两个div 因为vue会复用dom 导致多个div 动画效果失效了

            让vue不去复用dom 在属性中添加key值就行了 

            vue在transition中提供了mode 设置多个属性切换的效果

            mode='in-out'   需要显示的元素先显示，后要隐藏的元素再隐藏
                            先显示后隐藏
                            可以看成：in是显示 out是隐藏 书写是有先后顺序的

            mode='out-in'   out-in 要隐藏的元素先隐藏，需要展示的元素再进入
                            小结：先隐藏再显示
        -->
        <!-- <div v-if="show" key="hello">Hello World</div>
        <div v-else key="bye">Bye World</div> -->

        <!-- 
            多个组件的过渡动画有两种的方法 一种的把个个组件写清楚 采用if-else的结构 
            第二种的使用动态组件component 在methods中可以使用三元运算符来进行动态组件的切换
         -->

        <component :is="type"></component>
        <!-- <child v-if="show"></child>
        <child-one v-else></child-one> -->
      </transition>
      <button @click="handleClick">toggle</button>
    </div>

    <script>
      Vue.component("child", {
        template: "<div>child</div>",
      });
      Vue.component("child-one", {
        template: "<div>child-one</div>",
      });

      var vm = new Vue({
        el: "#root",
        data: {
          //   show: true,
          type: "child",
        },
        methods: {
          handleClick() {
            // this.show = !this.show;
            this.type = this.type === "child" ? "child-one" : "child";
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 5-6 Vue中的列表过渡

![image-20220907002920516](去哪儿网.assets/image-20220907002920516.png)

​	

**5-6_Vue中的列表过渡.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5-6 Vue中的列表过渡</title>
    <script src="vue.js"></script>
    <style>
      .v-enter,
      .v-leave-to {
        opacity: 0;
      }
      .v-enter-active,
      .v-leave-active {
        transition: opacity 1s;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <transition-group>
        <!-- <div v-for="(item,index) of list" :key="index"> -->
        <div v-for="item of list" :key="item.id">
          <!-- 能不用index做为key值的话尽量不用，会降低性能且可能出现问题 -->
          {{item.title}}
        </div>
      </transition-group>
      <button @click="handleBtnClick">Add</button>
    </div>

    <script>
      var count = 0;

      var vm = new Vue({
        el: "#root",
        data: {
          list: [],
        },
        methods: {
          handleBtnClick() {
            this.list.push({
              id: count++,
              title: "hello world",
            });
          },
        },
      });
    </script>
  </body>
</html>

```

​	

## 5-7 Vue中的动画封装
